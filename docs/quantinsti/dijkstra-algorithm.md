# Dijkstra 算法

> 原文：<https://blog.quantinsti.com/dijkstra-algorithm/>

马里奥·比萨

开始学习寻找最短路径的 Dijkstra 算法。我们简要回顾了 Kruskal 算法、Prim 算法、Johnson 算法和 Bellman 算法。我们将涵盖:

*   [什么是 Dijkstra 算法？](#what-is-the-dijkstra-algorithm)
*   [Dijkstra 算法是如何工作的？](#how-does-the-dijkstra-algorithm-work)
*   [Dijkstra 算法的伪代码](#pseudo-code-of-dijkstra-algorithm)
*   [Dijkstra 算法表](#dijkstra-algorithm-table)
*   [Dijkstra 算法时间复杂度](#dijkstra-algorithm-time-complexity)
*   [什么时候使用 Dijkstra 算法？](#when-to-use-the-dijkstra-algorithm)
*   [迪杰斯特拉算法 vs 克鲁斯卡尔算法](#dijkstra-algorithm-vs-kruskal-algorithm)
*   [Dijkstra 算法 vs Prim 算法](#dijkstra-algorithm-vs-prim-algorithm)
*   [普里姆算法 vs 克鲁斯卡尔算法](#prim-algorithm-vs-kruskal-algorithm)
*   [如何使用 Dijkstra 算法寻找最短路径？](#how-to-find-the-shortest-path-using-the-dijkstra-algorithm)
*   [为什么 Dijkstra 算法对于负权重会失败？](#why-does-the-dijkstra-algorithm-fail-for-negative-weights)

* * *

## 什么是 Dijkstra 算法？

Edsger W. Dijkstra (1930-2002) 是一位杰出的物理学家，他在分布式和并发计算以及其他数学领域取得了巨大的进步。

以他的名字命名的算法寻找最优解以获得图或网中的最短路径，尽管我们将在下面看到对算法的改进以提高效率。

Dijkstra 算法属于所谓的贪婪算法家族，因为它仅考虑当前时刻做出决策，而不考虑该决策可能如何影响未来，即，它在给定时刻做出最佳决策，而不考虑未来后果。

贪婪算法通常用于解决优化问题，例如选择最短路径或在计算机上执行任务的最佳顺序。

在这种情况下，贪婪算法在给定时刻选择最有希望的部分或任务，而不会在以后重新考虑这是否是最佳决策。因此，这是一个简单的算法实现，因为没有必要控制替代方案，也没有后续撤销以前的决定。

诸如 Dijkstra 算法、Kruskal 算法或 Prim 算法之类的贪婪算法的特征在于以下一般属性:

*   算法要求以最优的方式解决问题，在构建解决方案时，我们有一组或一列候选方案，如图的边、要计划的任务等。
*   随着算法的进行，两个集合被累积，一个包含已经被评估和选择的候选，另一个包含已经被评估但是被拒绝的候选。
*   有一个功能可以检查一组候选项是否形成了问题的解决方案，暂时忽略这是否是最佳解决方案。
*   还有第二个功能，测试给定的一组候选项是否可行，即是否有可能与其他候选项达成解决方案，以获得最终解决方案。同样，我们暂时忽略了解决方案是否是最优的。
*   还有第三个函数，用于选择既未被选中也未被拒绝的候选项，该候选项是在给定时间点最有希望的解决方案候选项。
*   最后，还有第四个函数叫做 objective，它返回我们已经找到的解，尽管严格来说它不是贪婪算法的一部分。

为了解决这个问题，我们寻找(第一)构成解的候选集，以及(第二)优化目标函数值的候选集。贪婪算法一步一步地进行。

最初，所选候选项的集合是空的，并且在每一步，最佳候选项被认为是通过选择函数添加到该集合中的。

*   如果所选候选的新扩展集对于一个解决方案是不可行的，无论最优与否，则该候选被拒绝。
*   如果候选的扩展集合仍然形成可能的解，无论最优与否，新的候选被添加到选择的候选集合中。

就这样，我们一步一步地继续前进，直到找到一个一定是最优的解决方案。

正如我们已经说过的，这些特征是贪婪算法所共有的，尽管我们将在后面看到，Dijkstra、Kruskal 和 Prim 贪婪算法具有独特的特征。

* * *

## Dijkstra 算法是如何工作的？

Dijkstra 算法解决了给定图形的最小路径问题。

给定一个有向图 **G = {N，E}** 其中 N 是 G 的节点集，E 是有向边集，每条边都有非负的长度，我们也可以讨论重量或成本，其中一个节点作为原点节点。

问题是确定从原点到其他每个节点的最短路径的长度。

正如我们在贪婪算法的一般特征中所看到的，Dijkstra 算法使用两组节点 S 和 c。组 S 保存所选节点的集合以及在给定时间每个节点到原始节点的距离。集合 C 包含所有未被选择且距离未知的候选节点。

由此我们推导出一个**不变性质 N = S U C** 。

也就是说，节点集等于所选节点集和未选节点集的并集。

在算法的第一步中，集合 S 只有节点原点，当算法完成时，它包含所有图节点以及每条边的成本。

如果从原点到特殊节点的路径中涉及的所有节点都在所选节点的集合 s 内，则我们称之为特殊节点。Dijkstra 算法维护一个矩阵 D，该矩阵在每一步都用集合 s 中每个节点的最短特殊路径的长度或权重进行更新

当试图将一个新的“v”节点添加到 S 时，到“v”的最短特殊路径也是到所有其他节点的最短路径(参见参考书中的演示)。当算法完成时，所有的节点都在 S 中，矩阵 D 包含了从原点到图中任何其他节点的所有特殊路径，从而解决了我们的最小路径问题。

在查看 Python 实现之前，让我们先看看 Dijkstra 算法在伪代码中是如何工作的。

* * *

## Dijkstra 算法的伪代码

Dijkstra 算法的伪代码是:
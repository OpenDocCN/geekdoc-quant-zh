["```pypython\n\nimport numpy as np\n\nfrom scipy.linalg import solve_banded\n\ndef finite_difference_american_option(S, K, r, sigma, T, is_call=True):\n\n# Define grid parameters and boundary conditions\n\n# Set up the coefficients for the finite difference scheme\n\n# Solve the system of equations using the boundary conditions\n\n# Return the option value at the initial stock price\n\npass\n\n# Example parameters for an American call option\n\noption_value = finite_difference_american_option(S=100, K=100, r=0.05, sigma=0.2, T=1, is_call=True)\n\n```", "```pypython\n\nfrom scipy.optimize import minimize\n\ndef calibration_error(params, market_prices, strikes, *args):\n\n# Calculate model prices using the current parameters\n\n# Return the sum of squared errors between market and model prices\n\npass\n\ndef calibrate_model(market_prices, strikes, initial_params, *args):\n\n# Minimize the calibration error to find the best-fit parameters\n\nresult = minimize(calibration_error, initial_params, args=(market_prices, strikes, *args))\n\nreturn result.x  # Optimized parameters\n\n```", "```pypython\n\nimport numpy as np\n\ndef european_call_finite_difference(S_max, K, r, sigma, T, M, N):\n\ndt = T/N  # time step\n\ndS = S_max/M  # price step\n\ngrid = np.zeros((M+1, N+1))  # initialize the grid\n\n# Set up the terminal condition\n\ngrid[:, -1] = np.maximum(np.arange(0, S_max+dS, dS) - K, 0)\n\n# Set up the coefficients for the finite difference scheme\n\nfor i in range(N-1, -1, -1):\n\nfor j in range(1, M):\n\n# apply the difference equation\n\npass  # Code to calculate option value at each node\n\nreturn grid[0, 0]  # return the option value at the initial node\n\n# Parameters for pricing the option\n\noption_value = european_call_finite_difference(S_max=100, K=100, r=0.05, sigma=0.2, T=1, M=100, N=1000)\n\n```", "```pypython\n\nimport numpy as np\n\nfrom numpy.fft import fft, ifft\n\ndef characteristic_function(params):\n\n# Define the characteristic function of the underlying asset's return\n\npass  # Placeholder for actual implementation\n\ndef call_option_fft(S, K, r, T, params):\n\nN = 210  # number of discretization points\n\ndelta_u = 0.25  # spacing of discretization points\n\nb = N * delta_u / 2  # upper bound of integration\n\nu = np.arange(N) * delta_u\n\nk = -b + u - np.log(K)\n\n# Apply the characteristic function to the frequency domain\n\nphi_u = characteristic_function(params)\n\n# Apply the FFT to the characteristic function values\n\nfft_values = fft(np.exp(-r * T) * phi_u)\n\n# Compute the call option prices using the inverse FFT\n\ncall_prices = np.real(ifft(fft_values)) * np.exp(-k) / np.pi\n\nreturn call_prices\n\n# Parameters for pricing the option\n\nparams = {\n\n'S': 100,     # Underlying asset price\n\n'K': 100,     # Strike price\n\n'r': 0.05,    # Risk-free interest rate\n\n'T': 1,       # Time to maturity\n\n# ... additional model parameters\n\n}\n\ncall_prices = call_option_fft(params)\n\n```", "```pypython\n\nimport scipy.optimize as optimize\n\n# Assume we have a function that calculates Heston model prices\n\ndef heston_model_prices(params, market_strikes, market_maturities):\n\n# Calculate option prices under the Heston model for given parameters\n\npass  # Placeholder for actual implementation\n\n# And a market data set of observed option prices\n\nmarket_data = {\n\n'strikes': [95, 100, 105],\n\n'maturities': [30, 60, 90],  # in days\n\n'prices': [10, 8, 6]  # hypothetical observed market prices\n\n}\n\n# Define the objective function for optimization\n\ndef objective_function(params, market_strikes, market_maturities, market_prices):\n\nmodel_prices = heston_model_prices(params, market_strikes, market_maturities)\n\nreturn np.sum((market_prices - model_prices)2)  # Sum of squared errors\n\n# Initial guess for the Heston model parameters\n\ninitial_params = [0.2, 0.1, 0.3, 0.5, 0.04]  # example starting values\n\n# Calibrate the model using the optimization routine\n\nresult = optimize.minimize(\n\nobjective_function,\n\ninitial_params,\n\nargs=(market_data['strikes'], market_data['maturities'], market_data['prices']),\n\nmethod='L-BFGS-B'  # example optimization method\n\n)\n\n# Extract the optimized parameters\n\noptimized_params = result.x\n\n# Now, the Heston model is calibrated, and we can use optimized_params for pricing\n\n```", "```pypython\n\nimport numpy as np\n\n# Black-Scholes PDE parameters\n\nsigma = 0.2  # volatility\n\nr = 0.05  # risk-free rate\n\nK = 100  # strike price\n\nT = 1  # time to maturity\n\n# Discretize the asset price space and time\n\nS_max = 2 * K  # maximum asset price considered\n\nds = 1  # asset price step size\n\ndt = 0.001  # time step size\n\nM = int(S_max / ds)  # number of asset price steps\n\nN = int(T / dt)  # number of time steps\n\n# Initialize the grid for option values\n\nV = np.zeros((M+1, N+1))\n\n# Set the boundary conditions for European call option\n\nV[:, -1] = np.maximum(np.arange(0, S_max+ds, ds) - K, 0)  # at maturity\n\nV[-1, :-1] = (S_max - K) * np.exp(-r * dt * np.arange(N))  # S = S_max\n\n# Solve the PDE using FDM\n\nfor j in range(N-1, -1, -1):\n\nfor i in range(1, M):\n\ndelta_S = i * ds\n\nV[i, j] = max(\n\nV[i, j+1] * np.exp(-r * dt),  # option to hold\n\n0.5 * dt * (sigma2 * i2 * (V[i+1, j+1] - 2*V[i, j+1] + V[i-1, j+1])\n\n+ r * i * (V[i+1, j+1] - V[i-1, j+1]) + V[i, j+1])  # FD approximation\n\n)\n\n# Extract the option value at S=K\n\noption_value_at_K = V[int(K/ds), 0]\n\nprint(f\"The numerical solution for the European call option price is: {option_value_at_K}\")\n\n```", "```pypython\n\nimport numpy as np\n\n# Assuming V is the grid of option values already computed by FDM\n\n# Vectorized operation to compute the option values at the next time step\n\nV[:, j] = np.maximum(V[:, j+1] * np.exp(-r * dt),  # option to hold\n\n0.5 * dt * (sigma2 * (np.arange(1, M)2)[:, None] *\n\n(V[2:, j+1] - 2*V[1:-1, j+1] + V[:-2, j+1]) +\n\nr * (np.arange(1, M)[:, None]) * (V[2:, j+1] - V[:-2, j+1]) + V[1:-1, j+1]))\n\n```"]
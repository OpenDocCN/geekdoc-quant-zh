["```pypython\n\nimport yfinance as yf\n\nimport numpy as np\n\ndef calculate_sma(data, window):\n\nsma = data.rolling(window=window).mean()\n\nreturn sma\n\ndef calculate_ema(data, window):\n\nema = data.ewm(span=window, adjust=False).mean()\n\nreturn ema\n\ndef start_bot():\n\nticker = yf.Ticker('AAPL')\n\ndata = ticker.history(period='1d', start='2020-1-1', end='2022-12-31')['Close']\n\nshort_window = 40\n\nlong_window = 100\n\nsignals = pd.DataFrame(index=data.index)\n\nsignals['signal'] = 0.0\n\nsignals['short_moving_avg'] = calculate_sma(data, short_window)\n\nsignals['long_moving_avg'] = calculate_sma(data, long_window)\n\nsignals['signal'][short_window:] = np.where(signals['short_moving_avg'][short_window:]\n\n> signals['long_moving_avg'][short_window:], 1.0, 0.0)  \n\nsignals['positions'] = signals['signal'].diff()\n\nif __name__ == \"__main__\":\n\nstart_bot()\n\n```", "```pypython\n\nimport pandas as pd\n\nimport numpy as np\n\nfrom oandapyV20 import API \n\nimport oandapyV20.endpoints.instruments as instruments\n\ndef get_candles(instrument):\n\nclient = API(access_token=\"YOUR_OANDA_API_TOKEN\")\n\nparams = {\"count\": 150,\"granularity\": \"H1\"}\n\ncandles = instruments.InstrumentsCandles(instrument=instrument,params=params)\n\nclient.request(candles)\n\nreturn candles.response['candles']\n\ndef calculate_z_score(series):\n\nreturn (series - series.mean()) / np.std(series)\n\ndef algo_fx():\n\ndata = pd.DataFrame(get_candles(\"EUR_USD\"))\n\ndata['close'] = data['mid'].apply(lambda x: float(x['c']))\n\ndata['z_score'] = calculate_z_score(data['close'])\n\nbuy = data['z_score'] < -1\n\nsell = data['z_score'] > 1\n\ndata['signal'] = np.where(buy, 1, np.where(sell, -1, 0))\n\nreturn data\n\nif __name__ == \"__main__\":\n\ndf = algo_fx()\n\nprint(df.tail())\n\n```", "```pypython\n\nimport pandas as pd\n\nimport numpy as np\n\nimport yfinance as yf\n\ndef calculate_z_score(series):\n\nreturn (series - series.mean()) / np.std(series)\n\ndef mean_reversion_algo(ticker):\n\n# Fetching data\n\ndata = yf.download(ticker, start='2021-01-01', end='2022-01-01')\n\ndata['returns'] = np.log(data['Close'] / data['Close'].shift(1))\n\n# Calculating the z-score\n\ndata['z_score'] = calculate_z_score(data['returns'])\n\nbuy = data['z_score'] < -1\n\nsell = data['z_score'] > 1\n\ndata['signal'] = np.where(buy, 1, np.where(sell, -1, 0))\n\nreturn data\n\nif __name__ == \"__main__\":\n\nticker = \"CL=F\"  #Crude Oil\n\ndf = mean_reversion_algo(ticker)\n\nprint(df.tail())\n\n```", "```pypython\n\nimport pandas as pd\n\nimport numpy as np\n\nimport yfinance as yf\n\ndef calculate_z_score(series):\n\nreturn (series - series.mean()) / np.std(series)\n\ndef fixed_income_algo(ticker):\n\n# Fetching data\n\ndata = yf.download(ticker, start='2021-01-01', end='2022-01-01')\n\ndata['returns'] = np.log(data['Close'] / data['Close'].shift(1))\n\n# Calculating the z-score\n\ndata['z_score'] = calculate_z_score(data['returns'])\n\nbuy = data['z_score'] < -1\n\nsell = data['z_score'] > 1\n\ndata['signal'] = np.where(buy, 1, np.where(sell, -1, 0))\n\nreturn data\n\nif __name__ == \"__main__\":\n\nticker = \"TLT\"\n\ndf = fixed_income_algo(ticker)\n\nprint(df.tail())\n\n```", "```pypython\n\nimport pandas as pd\n\nimport yfinance as yf\n\ndef calculate_relative_strength(etf_data, window_length):\n\ndelta = etf_data.diff()\n\nup, down = delta.copy(), delta.copy()\n\nup[up < 0] = 0\n\ndown[down > 0] = 0\n\nroll_up = up.rolling(window_length).mean()\n\nroll_down = abs(down.rolling(window_length).mean())\n\nRS = roll_up / roll_down\n\nRSI = 100.0 - (100.0 / (1.0 + RS))\n\nreturn RSI\n\ndef rsi_based_trade(ticker):\n\ndata = yf.download(ticker, start='2021-01-01', end='2022-01-01')\n\n# Calculate the 14-day RSI\n\ndata['RSI'] = calculate_relative_strength(data['Close'], 14)\n\n# Buy when RSI < 30 and sell when RSI > 70\n\ndata['Buy_Signal'] = data['RSI'] < 30\n\ndata['Sell_Signal'] = data['RSI'] > 70\n\nreturn data\n\nif __name__ == \"__main__\":\n\nticker = \"SPY\"\n\ndf = rsi_based_trade(ticker)\n\nprint(df.tail())\n\n```", "```pypython\n\nimport yfinance as yf\n\nimport numpy as np\n\nfrom datetime import datetime\n\ndef options_strategy(ticker):\n\nsymbol = yf.Ticker(ticker)\n\n# Load options chain\n\noptions_chain = symbol.option_chain(symbol.options[-1])\n\ncall_options = options_chain.calls\n\n# Filter for options with strike price higher than current price and volume > 100\n\ncall_options = call_options[(call_options.strike > symbol.info['regularMarketPrice']) & (call_options.volume > 100)]\n\nif not call_options.empty:\n\n# Select option with highest open interest\n\nselected_option = call_options.loc[call_options.openInterest.idxmax()]\n\nprint(f\"Buy Call Option {selected_option.contractSymbol} @ ${selected_option.lastTradeDate}\")\n\nelse:\n\nprint(\"No suitable options found.\")\n\nif __name__ == \"__main__\":\n\noptions_strategy(\"AAPL\")\n\n```", "```pypython\n\nimport pandas as pd\n\nimport yfinance as yf\n\ndef calc_momentum(price, period):\n\nreturn price / price.shift(period) - 1\n\ndef reit_strategy(ticker):\n\ndata = yf.download(ticker, period='1y')\n\ndata['momentum'] = calc_momentum(data['Close'], 21) # 21-day momentum\n\nbuy_signals = data['momentum'] > 0.05 # Buy signal if momentum > 5%\n\nsell_signals = data['momentum'] < -0.05 # Sell signal if momentum < -5%\n\nbuy_dates = data.loc[buy_signals].index\n\nsell_dates = data.loc[sell_signals].index\n\nfor buy_date in buy_dates:\n\nprint(f\"Buy {ticker} @ ${data.loc[buy_date, 'Close']} on {buy_date}\")\n\nfor sell_date in sell_dates:\n\nprint(f\"Sell {ticker} @ ${data.loc[sell_date, 'Close']} on {sell_date}\")\n\nif __name__ == \"__main__\":\n\nreit_strategy(\"VNQ\") # Vanguard Real Estate ETF\n\n```", "```pypython\n\nimport pandas as pd\n\nimport yfinance as yf\n\ndef calc_momentum(price, period):\n\nreturn price / price.shift(period) - 1\n\ndef crypto_strategy(ticker):\n\ndata = yf.download(ticker, period='1y')\n\ndata['momentum'] = calc_momentum(data['Close'], 21) # 21-day momentum\n\nbuy_signals = data['momentum'] > 0.10 # Buy signal if momentum > 10%\n\nsell_signals = data['momentum'] < -0.10 # Sell signal if momentum < -10%\n\nbuy_dates = data.loc[buy_signals].index\n\nsell_dates = data.loc[sell_signals].index\n\nfor buy_date in buy_dates:\n\nprint(f\"Buy {ticker} @ ${data.loc[buy_date, 'Close']} on {buy_date}\")\n\nfor sell_date in sell_dates:\n\nprint(f\"Sell {ticker} @ ${data.loc[sell_date, 'Close']} on {sell_date}\")\n\ncrypto_strategy(\"BTC-USD\") # Bitcoin\n\n```", "```pypython\n\nimport yfinance as yf\n\nimport numpy as np\n\ndef calculate_correlation(asset1, asset2, period):\n\ndata1 = yf.download(asset1, period='1y')['Close']\n\ndata2 = yf.download(asset2, period='1y')['Close']\n\nreturn data1.rolling(period).corr(data2)\n\ndef cross_asset_strategy(asset1, asset2, period, corr_threshold):\n\ncorrelation = calculate_correlation(asset1, asset2, period)\n\nbuy_signals = correlation < -corr_threshold\n\nsell_signals = correlation > corr_threshold\n\nreturn buy_signals, sell_signals\n\nbuy_signals, sell_signals = cross_asset_strategy('SPY', 'GLD', 60, 0.5)\n\nbuy_dates = buy_signals[buy_signals].index\n\nsell_dates = sell_signals[sell_signals].index\n\nfor buy_date in buy_dates:\n\nprint(f\"Buy {buy_date}\")\n\nfor sell_date in sell_dates:\n\nprint(f\"Sell {sell_date}\")\n\n```", "```pypython\n\ndef after_tax_return(profit, holding_period, tax_rates):\n\nif holding_period > 1:\n\nreturn profit * (1 - tax_rates['long_term'])\n\nelse:\n\nreturn profit * (1 - tax_rates['short_term'])\n\ndef trading_strategy(price_data, holding_period, tax_rates):\n\nbuy_signals = ...\n\nsell_signals = ...\n\nprofits = ...\n\nafter_tax_profits = [after_tax_return(profit, holding_period, tax_rates) for profit in profits]\n\n...\n\n```"]
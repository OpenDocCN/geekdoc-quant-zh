["```pypython\n\nimport numpy as np\n\nfrom scipy.stats import norm\n\ndef merton_model(S, K, T, r, sigma, q):\n\n# Adjusted spot price for dividend yield\n\nS_adj = S * np.exp(-q * T)\n\n# Calculate d1 and d2 using adjusted spot price\n\nd1 = (np.log(S_adj / K) + (r + 0.5 * sigma2) * T) / (sigma * np.sqrt(T))\n\nd2 = d1 - sigma * np.sqrt(T)\n\n# Merton's model calculations for call and put prices\n\ncall_price = S_adj * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n\nput_price = K * np.exp(-r * T) * norm.cdf(-d2) - S_adj * norm.cdf(-d1)\n\nreturn call_price, put_price\n\n```", "```pypython\n\ndef calculate_delta(S, K, T, r, sigma, q, option_type='call'):\n\nd1 = (np.log(S / K) + (r - q + 0.5 * sigma*2) * T) / (sigma * np.sqrt(T))\n\nif option_type == 'call':\n\nreturn np.exp(-q * T) * norm.cdf(d1)\n\nelse:\n\nreturn -np.exp(-q * T) * norm.cdf(-d1)\n\n```", "```pypython\n\ndef calculate_gamma(S, K, T, r, sigma, q):\n\nd1 = (np.log(S / K) + (r - q + 0.5 * sigma2) * T) / (sigma * np.sqrt(T))\n\nreturn np.exp(-q * T) * norm.pdf(d1) / (S * sigma * np.sqrt(T))\n\n```", "```pypython\n\ndef calculate_theta(S, K, T, r, sigma, q, option_type='call'):\n\nd1 = (np.log(S / K) + (r - q + 0.5 * sigma2) * T) / (sigma * np.sqrt(T))\n\nd2 = d1 - sigma * np.sqrt(T)\n\nif option_type == 'call':\n\nreturn -(S * norm.pdf(d1) * sigma * np.exp(-q * T) / (2 * np.sqrt(T))) - r * K * np.exp(-r * T) * norm.cdf(d2)\n\nelse:\n\nreturn -(S * norm.pdf(d1) * sigma * np.exp(-q * T) / (2 * np.sqrt(T))) + r * K * np.exp(-r * T) * norm.cdf(-d2)\n\n```", "```pypython\n\ndef calculate_vega(S, K, T, r, sigma, q):\n\nd1 = (np.log(S / K) + (r - q + 0.5 * sigma2) * T) / (sigma * np.sqrt(T))\n\nreturn S * np.exp(-q * T) * norm.pdf(d1) * np.sqrt(T)\n\n```", "```pypython\n\ndef calculate_rho(S, K, T, r, sigma, q, option_type='call'):\n\nd2 = (np.log(S / K) + (r - q - 0.5 * sigma2) * T) / (sigma * np.sqrt(T)) - sigma * np.sqrt(T)\n\nif option_type == 'call':\n\nreturn T * K * np.exp(-r * T) * norm.cdf(d2)\n\nelse:\n\nreturn -T * K * np.exp(-r * T) * norm.cdf(-d2)\n\n```", "```pypython\n\n# Here's an illustrative example that shows how constant volatility can\n\n# lead to discrepancies in option pricing:\n\n# Simplified Black-Scholes call option price calculation\n\ndef black_scholes_call(S, K, T, r, sigma):\n\nd1 = (np.log(S / K) + (r + 0.5 * sigma2) * T) / (sigma * np.sqrt(T))\n\nd2 = d1 - sigma * np.sqrt(T)\n\ncall_price = (S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2))\n\nreturn call_price\n\n# Let's assume a constant volatility of 20%\n\nconstant_volatility = 0.20\n\n# However, in reality, volatility may surge to 30% ahead of a major event\n\nactual_volatility = 0.30\n\n# We calculate the price difference for a call option using both volatilities\n\nprice_with_constant_vol = black_scholes_call(S=100, K=100, T=1, r=0.05, sigma=constant_volatility)\n\nprice_with_actual_vol = black_scholes_call(S=100, K=100, T=1, r=0.05, sigma=actual_volatility)\n\n# The discrepancy in pricing\n\nprice_discrepancy = price_with_actual_vol - price_with_constant_vol\n\n```"]
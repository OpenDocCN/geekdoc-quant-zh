["```pypython\n\nimport numpy as np\n\n# Sample price data\n\nprice_data = np.random.rand(100)\n\n# Function for moving average\n\ndef moving_average(data_set, periods):\n\nweights = np.ones(periods) / periods\n\nreturn np.convolve(data_set, weights, mode='valid')\n\n# Calculate & print the moving average\n\nprint(moving_average(price_data, 20))\n\n```", "```pypython\n\nimport pandas as pd\n\n# Sample closing prices\n\nclosing_prices = {'AAPL': pd.Series([317.69, 310.75, 320.35, 322.32, 321.45],\n\nindex=['2020-05-12', '2020-05-13', '2020-05-14', '2020-05-15', '2020-05-18'])}\n\n# Create the DataFrame\n\ndf = pd.DataFrame(closing_prices)\n\n# Percentage change\n\ndf.pct_change()\n\n```", "```pypython\n\nimport asyncio\n\nasync def execute_trade(asset):\n\nprint(f'Starting trade execution for {asset}...')\n\n# simulated delay for executing the trade\n\nawait asyncio.sleep(1)\n\nprint(f'Trade executed for {asset}!')\n\n# list of assets to trade\n\nassets = ['Asset A', 'Asset B', 'Asset C']\n\n# create a list of tasks\n\ntasks = [execute_trade(asset) for asset in assets]\n\n# run the tasks using asyncio\n\nasyncio.run(asyncio.wait(tasks))\n\n```", "```pypython\n\nfrom bs4 import BeautifulSoup\n\nimport requests\n\n# Retrieve the HTML of the webpage\n\nurl = 'https://www.financialexample.com'\n\nresponse = requests.get(url)\n\n# Parse HTML with BeautifulSoup\n\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# find and print the information needed (assume it's in a h1 tag)\n\ndata = soup.find('h1').text.strip()\n\nprint('Extracted data:', data)\n\n```", "```pypython\n\nfrom alpha_vantage.timeseries import TimeSeries\n\nAPI_KEY = 'your API key'\n\nts = TimeSeries(key=API_KEY, output_format='pandas')\n\n# Get real-time data for Apple stock\n\ndata, meta_data = ts.get_intraday(symbol='AAPL', interval='1min', outputsize='full')\n\nprint(data.head())\n\n```", "```pypython\n\nimport threading\n\nimport time\n\ndef calc_square(numbers):\n\nprint('Calculate square numbers')\n\nfor n in numbers:\n\ntime.sleep(0.2)\n\nprint(f'Square: {n*n}')\n\ndef calc_cube(numbers):\n\nprint('Calculate cube of numbers')\n\nfor n in numbers:\n\ntime.sleep(0.2)\n\nprint(f'Cube: {n*n*n}')\n\narr = [2,3,8,9]\n\nt = time.time()\n\nthread1 = threading.Thread(target=calc_square, args=(arr,))\n\nthread2 = threading.Thread(target=calc_cube, args=(arr,))\n\nthread1.start()\n\nthread2.start()\n\nthread1.join()\n\nthread2.join()\n\nprint('Completed in: ',time.time()-t)\n\n```", "```pypython\n\nfrom backtester import BackTester\n\nfrom google.cloud import dataflow\n\n# Initialize a Dataflow pipeline\n\noptions = dataflow.PipelineOptions()\n\npipeline = dataflow.Pipeline(options=options)\n\n# Define and apply a transformation that runs the backtest\n\nbacktest = pipeline | dataflow.Create(['AAPL', 'MSFT', 'GOOG']) \\\n\n| dataflow.ParDo(BackTester())\n\n# Run the pipeline\n\npipeline.run()\n\n```", "```pypython\n\nimport matplotlib.pyplot as plt\n\n```", "```pypython\n\nplt.figure(figsize=(14, 7))\n\nplt.plot(df.index, df['Close'], label='Close Price')\n\nplt.plot(df.index, df['SMA'], label='Short-term Moving Average')\n\nplt.plot(df.index, df['LMA'], label='Long-term Moving Average')\n\nplt.legend(loc='best')\n\nplt.title('Apple Stock Price with Moving Averages')\n\nplt.show()\n\n```", "```pypython\n\nimport seaborn as sns\n\n# Distribution plot for returns of Apple's stock\n\nreturns = df['Close'].pct_change().dropna()\n\nsns.distplot(returns, bins=100, color='blue', edgecolor=\"k\")\n\nplt.title('Return Distribution')\n\nplt.show()\n\n```", "```pypython\n\nimport websocket\n\nimport json\n\ndef on_open(ws):\n\nprint('Connection Opened')\n\nsub_request = { 'type':'subscribe', 'symbol':'AAPL' }\n\nws.send(json.dumps(sub_request))\n\ndef on_message(ws, message):\n\nprint('Received Message:', message)\n\ndef on_close(ws):\n\nprint('Connection Closed')\n\nws = websocket.WebSocketApp('wss://ws-api.example.com/',\n\non_open=on_open,\n\non_message=on_message,\n\non_close=on_close)\n\nws.run_forever()\n\n```", "```pypython\n\nimport ccxt\n\ndef start_bot():\n\nexchange = ccxt.binance({\n\n'apiKey': 'YOUR_API_KEY',\n\n'secret': 'YOUR_SECRET',\n\n})\n\ntarget_price = 50000\n\nbalance = exchange.fetch_balance()\n\nwhile True:\n\nmarket_price = exchange.fetch_ticker('BTC/USDT')['last']\n\nif market_price < target_price:\n\nif balance['USDT'] > market_price:\n\norder = exchange.create_market_buy_order('BTC/USDT', balance['USDT'] / market_price)\n\nprint(order)\n\nelse:\n\nif balance['BTC'] > 0:\n\norder = exchange.create_market_sell_order('BTC/USDT', balance['BTC'])\n\nprint(order)\n\ntime.sleep(60)\n\nif __name__ == \"__main__\":\n\nstart_bot()\n\n```"]
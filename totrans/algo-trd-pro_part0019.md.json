["```pypython\n\nimport pandas as pd\n\n# Load the options transactions dataset\n\ntransactions_df = pd.read_csv('options_transactions.csv')\n\n# Remove duplicate transactions\n\ncleaned_df = transactions_df.drop_duplicates(subset=['transaction_id'])\n\n```", "```pypython\n\nfrom sklearn.preprocessing import MinMaxScaler\n\n# Assume 'cleaned_df' is the cleaned dataframe from the previous step\n\nscaler = MinMaxScaler()\n\n# Normalize the 'price' column\n\ncleaned_df['price_scaled'] = scaler.fit_transform(cleaned_df[['price']])\n\n```", "```pypython\n\nfrom scipy import stats\n\n# Assume 'cleaned_df' has a 'price_scaled' column from earlier steps\n\nz_scores = stats.zscore(cleaned_df['price_scaled'])\n\nabs_z_scores = np.abs(z_scores)\n\nfiltered_entries = (abs_z_scores < 3).all(axis=1)\n\nfinal_df = cleaned_df[filtered_entries]\n\n```", "```pypython\n\n# Assume 'final_df' is the dataframe after outlier treatment\n\n# Assume 'corporate_actions_df' contains information about splits and dividends\n\nfor index, action in corporate_actions_df.iterrows():\n\nif action['type'] == 'split':\n\n# Adjust the prices based on the split ratio\n\nfinal_df.loc[final_df['date'] >= action['effective_date'], 'price_scaled'] /= action['ratio']\n\nelif action['type'] == 'dividend':\n\n# Adjust the prices based on the dividend amount\n\nfinal_df.loc[final_df['date'] >= action['effective_date'], 'price_scaled'] -= action['amount']\n\n```", "```pypython\n\nimport pandas as pd\n\n# Load the options dataset\n\noptions_df = pd.read_csv('options_data.csv')\n\n# Detect missing values in the dataset\n\nmissing_values = options_df.isnull().sum()\n\n```", "```pypython\n\n# Assume 'options_df' has missing values detected\n\n# Impute missing values for a numerical column with the column's mean\n\noptions_df['strike_price'].fillna(options_df['strike_price'].mean(), inplace=True)\n\n# Impute missing values for a categorical column with the mode\n\noptions_df['option_type'].fillna(options_df['option_type'].mode()[0], inplace=True)\n\n```", "```pypython\n\n# Drop rows with any missing values\n\noptions_df.dropna(inplace=True)\n\n```", "```pypython\n\n# Script to compare dataset properties before and after missing data handling\n\ndef compare_datasets(before_df, after_df):\n\nfor column in before_df.columns:\n\nbefore_mean = before_df[column].mean()\n\nafter_mean = after_df[column].mean()\n\nprint(f'Column: {column}')\n\nprint(f'Before Mean: {before_mean} | After Mean: {after_mean}\\n')\n\n# Assume 'original_df' is the original dataset and 'options_df' is after missing data handling\n\ncompare_datasets(original_df, options_df)\n\n```", "```pypython\n\nimport pandas as pd\n\n# Load the options dataset\n\noptions_df = pd.read_csv('options_data.csv')\n\n# Convert 'timestamp' from string to datetime\n\noptions_df['timestamp'] = pd.to_datetime(options_df['timestamp'])\n\n# Convert categorical 'option_type' to numerical encoding\n\noptions_df['option_type'] = options_df['option_type'].astype('category').cat.codes\n\n```", "```pypython\n\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\n\n# Assume 'options_df' has numerical columns 'strike_price' and 'volume'\n\n# Min-max scaling\n\nmin_max_scaler = MinMaxScaler()\n\noptions_df['strike_price_scaled'] = min_max_scaler.fit_transform(options_df[['strike_price']])\n\n# Z-score standardization\n\nstandard_scaler = StandardScaler()\n\noptions_df['volume_standardized'] = standard_scaler.fit_transform(options_df[['volume']])\n\n```", "```pypython\n\nimport matplotlib.pyplot as plt\n\n# Function to plot original and transformed data for comparison\n\ndef plot_data_transformation(before_series, after_series, title):\n\nplt.figure(figsize=(10, 4))\n\nplt.subplot(1, 2, 1)\n\nplt.hist(before_series, bins=50)\n\nplt.title(f'Original {title}')\n\nplt.subplot(1, 2, 2)\n\nplt.hist(after_series, bins=50)\n\nplt.title(f'Transformed {title}')\n\nplt.show()\n\n# Plotting the data before and after scaling for 'strike_price'\n\nplot_data_transformation(options_df['strike_price'], options_df['strike_price_scaled'], 'Strike Price')\n\n```", "```pypython\n\n# Calculate IQR\n\nQ1 = options_df['volume'].quantile(0.25)\n\nQ3 = options_df['volume'].quantile(0.75)\n\nIQR = Q3 - Q1\n\n# Define boundaries for outliers\n\nlower_bound = Q1 - 1.5 * IQR\n\nupper_bound = Q3 + 1.5 * IQR\n\n# Detect outliers\n\noutliers = options_df[(options_df['volume'] < lower_bound) | (options_df['volume'] > upper_bound)]\n\n```", "```pypython\n\nfrom scipy.stats.mstats import winsorize\n\n# Apply winsorization to the 'volume' column\n\noptions_df['volume_winsorized'] = winsorize(options_df['volume'], limits=[0.01, 0.01])\n\n```", "```pypython\n\nimport numpy as np\n\n# Apply log transformation to 'strike_price'\n\noptions_df['strike_price_log'] = np.log(options_df['strike_price'])\n\n```", "```pypython\n\n# Function to compare original and treated data\n\ndef compare_distributions(original, treated, title):\n\nplt.figure(figsize=(10, 5))\n\nplt.subplot(1, 2, 1)\n\nplt.hist(original, bins=50, alpha=0.5, label='Original')\n\nplt.hist(treated, bins=50, alpha=0.5, label='Treated')\n\nplt.title(title)\n\nplt.legend()\n\n# Compare the 'volume' distributions before and after winsorization\n\ncompare_distributions(options_df['volume'], options_df['volume_winsorized'], 'Volume Distribution')\n\n```", "```pypython\n\n# Adjusting option strike prices for a 2-for-1 stock split\n\noptions_df['adjusted_strike'] = options_df['strike_price'] / 2\n\n```", "```pypython\n\n# Example: Adjusting option strike prices for a $0.50 cash dividend\n\ndividend_amount = 0.50\n\noptions_df['ex_dividend_date'] = pd.to_datetime(options_df['ex_dividend_date'])\n\n# Adjust strikes on contracts with an ex-dividend date within their lifespan\n\noptions_df['adjusted_strike'] = np.where(options_df['expiration_date'] > options_df['ex_dividend_date'],\n\noptions_df['strike_price'] - dividend_amount,\n\noptions_df['strike_price'])\n\n```", "```pypython\n\nimport pandas as pd\n\n# Assume we have a DataFrame 'options_portfolio' with options data\n\n# including columns for 'strike_price', 'number_of_options', 'ex_dividend_date', and 'split_ratio'\n\n# Function to adjust for stock splits\n\ndef adjust_for_splits(options_portfolio, split_date, split_ratio):\n\noptions_portfolio.loc[options_portfolio.index >= split_date, 'strike_price'] /= split_ratio\n\noptions_portfolio.loc[options_portfolio.index >= split_date, 'number_of_options'] *= split_ratio\n\nreturn options_portfolio\n\n# Function to adjust for dividends\n\ndef adjust_for_dividends(options_portfolio, ex_dividend_date, dividend_amount):\n\noptions_portfolio.loc[options_portfolio['ex_dividend_date'] <= ex_dividend_date, 'strike_price'] -= dividend_amount\n\nreturn options_portfolio\n\n# Applying the functions for a hypothetical split and dividend\n\nsplit_date = pd.Timestamp('2023-05-01')\n\nsplit_ratio = 2  # 2-for-1 split\n\nex_dividend_date = pd.Timestamp('2023-06-15')\n\ndividend_amount = 1.00  # $1.00 dividend\n\noptions_portfolio = adjust_for_splits(options_portfolio, split_date, split_ratio)\n\noptions_portfolio = adjust_for_dividends(options_portfolio, ex_dividend_date, dividend_amount)\n\n```", "```pypython\n\n# Function to adjust option strikes for dividends\n\ndef adjust_strikes_for_dividends(options_data, dividend_info):\n\nfor ticker, dividend in dividend_info.items():\n\n# Filter options for the specific ticker\n\noptions = options_data[options_data['ticker'] == ticker]\n\n# Adjust strike prices\n\noptions['adjusted_strike'] = options.apply(\n\nlambda x: x['strike_price'] - dividend['amount']\n\nif x['ex_dividend_date'] <= dividend['date'] else x['strike_price'],\n\naxis=1\n\n)\n\n# Update the main DataFrame\n\noptions_data.update(options)\n\nreturn options_data\n\n# Sample dividend information\n\ndividend_info = {\n\n'AAPL': {'date': pd.Timestamp('2023-08-10'), 'amount': 0.22},\n\n'MSFT': {'date': pd.Timestamp('2023-08-15'), 'amount': 0.56}\n\n}\n\n# Adjust the DataFrame 'options_data' for dividends\n\noptions_data = adjust_strikes_for_dividends(options_data, dividend_info)\n\n```", "```pypython\n\n# Function to adjust options for mergers or acquisitions\n\ndef adjust_options_for_mergers(options_data, merger_info):\n\nfor ticker, merger in merger_info.items():\n\n# Filter options for the specific ticker\n\noptions = options_data[options_data['ticker'] == ticker]\n\n# Adjust deliverables and strike prices based on the merger terms\n\noptions['adjusted_deliverable'] = options['deliverable'] * merger['deliverable_multiplier']\n\noptions['adjusted_strike'] = options['strike_price'] / merger['strike_divisor']\n\n# Update the main DataFrame\n\noptions_data.update(options)\n\nreturn options_data\n\n# Sample merger information\n\nmerger_info = {\n\n'TWTR': {'deliverable_multiplier': 1.25, 'strike_divisor': 1.00}\n\n}\n\n# Adjust the DataFrame 'options_data' for a merger\n\noptions_data = adjust_options_for_mergers(options_data, merger_info)\n\n```"]